/*_________________________________________________________

onemax.ez // Evolve individuals containing 111111111111111111...
__________________________________________________________*/

\User declarations :
#define SIZE 8192
#define NB_SIN 100    // passer le nombre de sinus à 6
#define X_MAX 7.0

float donnees[SIZE][2];

\end

\User functions:
\end

\User CUDA:
\end

\Before everything else function:

for (int d=0;d<SIZE;d++){
  float x=random(0.0,X_MAX);
  donnees[d][0]=x;
  float y=0;
  y=(601*sin(1009*x+6.28/2))+(599*sin(1013*x+6.28/3))+(593*sin(1019*x+6.28/5))+(587*sin(1021*x+6.28/7))+(577*sin(1031*x+6.28/11))+(571*sin(1033*x+6.28/13))+(569*sin(1039*x+6.28/17))+(563*sin(1049*x+6.28/19))+(557*sin(1051*x+6.28/23))+(547*sin(1061*x+6.28/29))+(541*sin(1063*x+6.28/31))+(523*sin(1069*x+6.28/37))+(521*sin(1087*x+6.28/41))+(509*sin(1091*x+6.28/43))+(503*sin(1093*x+6.28/47))+(499*sin(1097*x+6.28/53))+(491*sin(1103*x+6.28/59))+(487*sin(1109*x+6.28/61))+(479*sin(1117*x+6.28/67))+(467*sin(1123*x+6.28/71))+(463*sin(1129*x+6.28/73))+(461*sin(1151*x+6.28/79))+(457*sin(1153*x+6.28/83))+(449*sin(1163*x+6.28/89))+(443*sin(1171*x+6.28/97))+(439*sin(1181*x+6.28/101))+(433*sin(1187*x+6.28/103))+(431*sin(1193*x+6.28/107))+(421*sin(1201*x+6.28/109))+(419*sin(1213*x+6.28/113))+(409*sin(1217*x+6.28/127))+(401*sin(1223*x+6.28/131))+(397*sin(1229*x+6.28/137))+(389*sin(1231*x+6.28/139))+(383*sin(1237*x+6.28/149))+(379*sin(1249*x+6.28/151))+(373*sin(1259*x+6.28/157))+(367*sin(1277*x+6.28/163))+(359*sin(1279*x+6.28/167))+(353*sin(1283*x+6.28/173))+(349*sin(1289*x+6.28/179))+(347*sin(1291*x+6.28/181))+(337*sin(1297*x+6.28/191))+(331*sin(1301*x+6.28/193))+(317*sin(1303*x+6.28/197))+(313*sin(1307*x+6.28/199))+(311*sin(1319*x+6.28/211))+(307*sin(1321*x+6.28/223))+(293*sin(1327*x+6.28/227))+(283*sin(1361*x+6.28/229))+(281*sin(1367*x+6.28/233))+(277*sin(1373*x+6.28/239))+(271*sin(1381*x+6.28/241))+(269*sin(1399*x+6.28/251))+(263*sin(1409*x+6.28/257))+(257*sin(1423*x+6.28/263))+(251*sin(1427*x+6.28/269))+(241*sin(1429*x+6.28/271))+(239*sin(1433*x+6.28/277))+(233*sin(1439*x+6.28/281))+(229*sin(1447*x+6.28/283))+(227*sin(1451*x+6.28/293))+(223*sin(1453*x+6.28/307))+(211*sin(1459*x+6.28/311))+(199*sin(1471*x+6.28/313))+(197*sin(1481*x+6.28/317))+(193*sin(1483*x+6.28/331))+(191*sin(1487*x+6.28/337))+(181*sin(1489*x+6.28/347))+(179*sin(1493*x+6.28/349))+(173*sin(1499*x+6.28/353))+(167*sin(1511*x+6.28/359))+(163*sin(1523*x+6.28/367))+(157*sin(1531*x+6.28/373))+(151*sin(1543*x+6.28/379))+(149*sin(1549*x+6.28/383))+(139*sin(1553*x+6.28/389))+(137*sin(1559*x+6.28/397))+(131*sin(1567*x+6.28/401))+(127*sin(1571*x+6.28/409))+(113*sin(1579*x+6.28/419))+(109*sin(1583*x+6.28/421))+(107*sin(1597*x+6.28/431))+(103*sin(1601*x+6.28/433))+(101*sin(1607*x+6.28/439))+(97*sin(1609*x+6.28/443))+(89*sin(1613*x+6.28/449))+(83*sin(1619*x+6.28/457))+(79*sin(1621*x+6.28/461))+(73*sin(1627*x+6.28/463))+(71*sin(1637*x+6.28/467))+(67*sin(1657*x+6.28/479))+(61*sin(1663*x+6.28/487))+(59*sin(1667*x+6.28/491))+(53*sin(1669*x+6.28/499))+(47*sin(1693*x+6.28/503))+(43*sin(1697*x+6.28/509))+(41*sin(1699*x+6.28/521))+(37*sin(1709*x+6.28/523))+(31*sin(1721*x+6.28/541));
  donnees[d][1]=y;
}

\end

\After everything else function:

printf("On cherche : (601*sin(1009*x+6.28/2))\n");

printf("On trouve : \n");
for(int j=0;j</*NB_SIN*/1;j++){
  printf("%f*sin(%f*x+%f)+",bBest->s[j*3+0],bBest->s[j*3+1],bBest->s[j*3+2]);
}
printf("\n");
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\User classes :
GenomeClass {
  float s[NB_SIN*3]; // a1,f1,p1,a2,f2,p2,...
}
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser : // "initializer" is also accepted
  
  for(int i=0; i<NB_SIN; i++ ) {
    Genome.s[i*3+0] = random(30,602);
    Genome.s[i*3+1] = random(1008,1722);
    Genome.s[i*3+2] = random(0.0,6.28);
  }
\end
    
\GenomeClass::crossover :
  int nLocus=random(1,NB_SIN);

  for (int i=nLocus;i<NB_SIN;i++){
     child.s[i*3+0]=parent2.s[i*3+0];
     child.s[i*3+1]=parent2.s[i*3+1];
     child.s[i*3+2]=parent2.s[i*3+2];
  }
\end

\GenomeClass::mutator :
  for (int i=0;i<NB_SIN*3;i++){
    if (tossCoin(.1)) Genome.s[i]+=random(-1.0,1.0);
  }
\end




\GenomeClass::evaluator : // Returns the score
  float fScore=0;
  for (int i=0;i<SIZE;i++){
    float x=donnees[i][0];
    float y=0;
    for (int j=0;j<1;j++){ //evalue que par rapport à la première
      y+=Genome.s[j*3+0]*sin(Genome.s[j*3+1]*x+Genome.s[j*3+2]);
    }
    fScore+=fabs(y-donnees[i][1])*X_MAX/(float)SIZE;
  }

  return fScore;
\end

\User Makefile options:
\end

\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 200   	// NB_GEN
  Time limit: 0 			          // In seconds, 0 to deactivate
  Population size : 1000		    //POP_SIZE
  Offspring size : 1000 // 40%
  Mutation probability : 1       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : minimise      // Maximise
  Selection operator: Tournament 2
  Surviving parents: 100% //percentage or absolute
  Surviving offspring: 100%
  Reduce parents operator: Tournament 1
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Weak			//Weak or Strong
  Elite: 1
  Print stats: true				//Default: 1
  Generate csv stats file:false
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				//Default: 0

  Remote island model: true             // mis à "true"
  //IP file: ip.txt 			//File containing all the remote island's IP
  Server port : 2929
  Migration probability: 0.3

  Save population: false
  Start from file:false
\end
